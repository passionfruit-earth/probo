package trust_v1

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"time"

	"go.gearno.de/kit/log"
	"go.probo.inc/probo/pkg/coredata"
	"go.probo.inc/probo/pkg/gid"
	"go.probo.inc/probo/pkg/iam"
	"go.probo.inc/probo/pkg/page"
	"go.probo.inc/probo/pkg/server/api/authn"
	"go.probo.inc/probo/pkg/server/api/compliancepage"
	"go.probo.inc/probo/pkg/server/api/trust/v1/schema"
	"go.probo.inc/probo/pkg/server/api/trust/v1/types"
	"go.probo.inc/probo/pkg/server/gqlutils"
	"go.probo.inc/probo/pkg/trust"
)

// Framework is the resolver for the framework field.
func (r *auditResolver) Framework(ctx context.Context, obj *types.Audit) (*types.Framework, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	audit, err := trustService.Audits.Get(ctx, obj.ID)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot load audit", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	framework, err := trustService.Frameworks.Get(ctx, audit.FrameworkID)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot load framework", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return types.NewFramework(framework), nil
}

// Report is the resolver for the report field.
func (r *auditResolver) Report(ctx context.Context, obj *types.Audit) (*types.Report, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	audit, err := trustService.Audits.Get(ctx, obj.ID)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot load audit", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	if audit.ReportID == nil {
		return nil, nil
	}

	report, err := trustService.Reports.Get(ctx, *audit.ReportID)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot load report", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return types.NewReport(report), nil
}

// IsUserAuthorized is the resolver for the isUserAuthorized field.
func (r *documentResolver) IsUserAuthorized(ctx context.Context, obj *types.Document) (bool, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())
	trustCenter := compliancepage.CompliancePageFromContext(ctx)

	document, err := trustService.Documents.Get(ctx, obj.ID)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot load document", log.Error(err))
		return false, gqlutils.Internal(ctx)
	}

	if document.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		return true, nil
	}

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return false, nil
	}

	documentAccess, err := trustService.TrustCenterAccesses.LoadDocumentAccess(
		ctx,
		trustCenter.ID,
		identity.EmailAddress,
		obj.ID,
	)
	if err != nil {
		if errors.Is(err, trust.ErrMembershipNotFound) {
			return false, nil
		}
		if errors.Is(err, trust.ErrMembershipInactive) {
			return false, nil
		}
		if errors.Is(err, trust.ErrDocumentAccessNotFound) {
			return false, nil
		}

		r.logger.ErrorCtx(ctx, "cannot check document access", log.Error(err))
		return false, gqlutils.Internal(ctx)
	}

	return documentAccess.Status == coredata.TrustCenterDocumentAccessStatusGranted, nil
}

// HasUserRequestedAccess is the resolver for the hasUserRequestedAccess field.
func (r *documentResolver) HasUserRequestedAccess(ctx context.Context, obj *types.Document) (bool, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())
	trustCenter := compliancepage.CompliancePageFromContext(ctx)

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return false, nil // User is not authenticated, so no access requested
	}

	// Try to load document access - if it exists (regardless of active status), user has requested it
	_, err := trustService.TrustCenterAccesses.LoadDocumentAccess(
		ctx,
		trustCenter.ID,
		identity.EmailAddress,
		obj.ID,
	)
	if err != nil {
		// FIXME check for not found and return without error in this case
		// r.logger.ErrorCtx(ctx, "cannot check trust center file access", log.Error(err))
		// return false, gqlutils.Internal(ctx)
		return false, nil
	}
	return true, nil // Access exists (requested)
}

// LightLogoURL is the resolver for the lightLogoURL field.
func (r *frameworkResolver) LightLogoURL(ctx context.Context, obj *types.Framework) (*string, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	return trustService.Frameworks.GenerateLightLogoURL(ctx, obj.ID, 1*time.Hour)
}

// DarkLogoURL is the resolver for the darkLogoURL field.
func (r *frameworkResolver) DarkLogoURL(ctx context.Context, obj *types.Framework) (*string, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	return trustService.Frameworks.GenerateDarkLogoURL(ctx, obj.ID, 1*time.Hour)
}

// SendMagicLink is the resolver for the sendMagicLink field.
func (r *mutationResolver) SendMagicLink(ctx context.Context, input types.SendMagicLinkInput) (*types.SendMagicLinkPayload, error) {
	trustCenter := compliancepage.CompliancePageFromContext(ctx)

	req := &iam.SendMagicLinkRequest{
		Email:            input.Email,
		CompliancePageID: &trustCenter.ID,
		OrganizationID:   trustCenter.OrganizationID,
		URLPath:          "verify-magic-link",
	}

	if err := r.iam.AuthService.SendMagicLink(ctx, req); err != nil {
		r.logger.ErrorCtx(ctx, "cannot send magic link", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return nil, nil
}

// VerifyMagicLink is the resolver for the verifyMagicLink field.
func (r *mutationResolver) VerifyMagicLink(ctx context.Context, input types.VerifyMagicLinkInput) (*types.VerifyMagicLinkPayload, error) {
	_, session, err := r.iam.AuthService.OpenSessionWithMagicLink(ctx, input.Token)
	if err != nil {
		var errInvalidToken *iam.ErrInvalidToken
		if errors.As(err, &errInvalidToken) {
			return nil, gqlutils.Invalid(ctx, err)
		}

		r.logger.ErrorCtx(ctx, "cannot open session with magic link", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	w := gqlutils.HTTPResponseWriterFromContext(ctx)
	r.sessionCookie.Set(w, session)

	return &types.VerifyMagicLinkPayload{
		Success: true,
	}, nil
}

// RequestAllAccesses is the resolver for the requestAllAccesses field.
func (r *mutationResolver) RequestAllAccesses(ctx context.Context) (*types.RequestAccessesPayload, error) {
	trustCenter := compliancepage.CompliancePageFromContext(ctx)
	trustService := r.TrustService(ctx, trustCenter.ID.TenantID())

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return nil, gqlutils.Unauthenticatedf(ctx, "authentication is required to request access")
	}

	access, err := trustService.TrustCenterAccesses.Request(
		ctx,
		&trust.TrustCenterAccessRequest{
			TrustCenterID: trustCenter.ID,
			Email:         identity.EmailAddress,
			FullName:      identity.FullName,
			DocumentIDs:   nil,
			ReportIDs:     nil,
		},
	)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot create trust center access", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return &types.RequestAccessesPayload{
		TrustCenterAccess: &types.TrustCenterAccess{
			ID:        access.ID,
			Email:     access.Email,
			Name:      access.Name,
			CreatedAt: access.CreatedAt,
			UpdatedAt: access.UpdatedAt,
		},
	}, nil
}

// ExportDocumentPDF is the resolver for the exportDocumentPDF field.
func (r *mutationResolver) ExportDocumentPDF(ctx context.Context, input types.ExportDocumentPDFInput) (*types.ExportDocumentPDFPayload, error) {
	trustService := r.TrustService(ctx, input.DocumentID.TenantID())
	trustCenter := compliancepage.CompliancePageFromContext(ctx)

	document, err := trustService.Documents.Get(ctx, input.DocumentID)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot load document", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	if document.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		pdf, err := trustService.Documents.ExportPDFWithoutWatermark(ctx, input.DocumentID)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot export document PDF", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}

		return &types.ExportDocumentPDFPayload{
			Data: fmt.Sprintf("data:application/pdf;base64,%s", base64.StdEncoding.EncodeToString(pdf)),
		}, nil
	}

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return nil, gqlutils.Unauthenticated(ctx, errors.New("unauthenticated"))
	}

	ndaExists := true
	hasAcceptedNDA := false

	if trustCenter.NonDisclosureAgreementFileID == nil {
		ndaExists = false
	}

	if ndaExists {
		hasAcceptedNDA, err = trustService.TrustCenterAccesses.HasAcceptedNonDisclosureAgreement(
			ctx,
			trustCenter.ID,
			identity.EmailAddress,
		)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot check if user has accepted NDA", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}
	}

	documentAccess, err := trustService.TrustCenterAccesses.LoadDocumentAccess(
		ctx,
		trustCenter.ID,
		identity.EmailAddress,
		input.DocumentID,
	)
	if err != nil {
		// FIXME check for not found and return without error in this case
		// r.logger.ErrorCtx(ctx, "cannot check document access", log.Error(err))
		// return false, gqlutils.Internal(ctx)
		return nil, nil
	}

	if documentAccess.Status != coredata.TrustCenterDocumentAccessStatusGranted {
		return nil, gqlutils.Forbiddenf(ctx, "access denied: no permission to access this document")
	}

	if ndaExists && !hasAcceptedNDA {
		return nil, gqlutils.Forbiddenf(ctx, "user has not accepted NDA")
	}

	pdf, err := trustService.Documents.ExportPDF(ctx, input.DocumentID, identity.EmailAddress)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot export document PDF", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return &types.ExportDocumentPDFPayload{
		Data: fmt.Sprintf("data:application/pdf;base64,%s", base64.StdEncoding.EncodeToString(pdf)),
	}, nil
}

// ExportReportPDF is the resolver for the exportReportPDF field.
func (r *mutationResolver) ExportReportPDF(ctx context.Context, input types.ExportReportPDFInput) (*types.ExportReportPDFPayload, error) {
	trustService := r.TrustService(ctx, input.ReportID.TenantID())

	trustCenter := compliancepage.CompliancePageFromContext(ctx)

	audit, err := trustService.Audits.GetByReportID(ctx, input.ReportID)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot load audit", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	if audit.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		pdf, err := trustService.Reports.ExportPDFWithoutWatermark(ctx, input.ReportID)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot export report PDF", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}

		return &types.ExportReportPDFPayload{
			Data: fmt.Sprintf("data:application/pdf;base64,%s", base64.StdEncoding.EncodeToString(pdf)),
		}, nil
	}

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return nil, gqlutils.Unauthenticatedf(ctx, "unauthenticated")
	}

	ndaExists := true
	hasAcceptedNDA := false

	if trustCenter.NonDisclosureAgreementFileID == nil {
		ndaExists = false
	}

	if ndaExists {
		hasAcceptedNDA, err = trustService.TrustCenterAccesses.HasAcceptedNonDisclosureAgreement(
			ctx,
			trustCenter.ID,
			identity.EmailAddress,
		)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot check if user has accepted NDA", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}
	}

	reportAccess, err := trustService.TrustCenterAccesses.LoadReportAccess(
		ctx,
		trustCenter.ID,
		identity.EmailAddress,
		input.ReportID,
	)
	if err != nil {
		// FIXME check for not found and return without error in this case
		// r.logger.ErrorCtx(ctx, "cannot check report access", log.Error(err))
		// return false, gqlutils.Internal(ctx)
		return nil, nil
	}

	if reportAccess.Status != coredata.TrustCenterDocumentAccessStatusGranted {
		return nil, gqlutils.Forbiddenf(ctx, "access denied: no permission to access this report")
	}

	if ndaExists && !hasAcceptedNDA {
		return nil, gqlutils.Forbiddenf(ctx, "user has not accepted NDA")
	}

	pdf, err := trustService.Reports.ExportPDF(ctx, input.ReportID, identity.EmailAddress)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot export report PDF", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return &types.ExportReportPDFPayload{
		Data: fmt.Sprintf("data:application/pdf;base64,%s", base64.StdEncoding.EncodeToString(pdf)),
	}, nil
}

// ExportTrustCenterFile is the resolver for the exportTrustCenterFile field.
func (r *mutationResolver) ExportTrustCenterFile(ctx context.Context, input types.ExportTrustCenterFileInput) (*types.ExportTrustCenterFilePayload, error) {
	trustCenter := compliancepage.CompliancePageFromContext(ctx)
	trustService := r.TrustService(ctx, trustCenter.ID.TenantID())

	trustCenterFile, err := trustService.TrustCenterFiles.Get(ctx, input.TrustCenterFileID)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot load trust center file", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	if trustCenterFile.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		fileData, err := trustService.TrustCenterFiles.ExportFileWithoutWatermark(ctx, input.TrustCenterFileID)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot export trust center file", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}

		return &types.ExportTrustCenterFilePayload{
			Data: fmt.Sprintf("data:application/pdf;base64,%s", base64.StdEncoding.EncodeToString(fileData)),
		}, nil
	}

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return nil, gqlutils.Unauthenticatedf(ctx, "unauthenticated")
	}

	ndaExists := true
	hasAcceptedNDA := false

	if trustCenter.NonDisclosureAgreementFileID == nil {
		ndaExists = false
	}

	if ndaExists {
		hasAcceptedNDA, err = trustService.TrustCenterAccesses.HasAcceptedNonDisclosureAgreement(ctx,
			trustCenter.ID,
			identity.EmailAddress,
		)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot check if user has accepted NDA", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}
	}

	fileAccess, err := trustService.TrustCenterAccesses.LoadTrustCenterFileAccess(ctx,
		trustCenter.ID,
		identity.EmailAddress,
		input.TrustCenterFileID,
	)
	if err != nil {
		// FIXME check for not found and return without error in this case
		// r.logger.ErrorCtx(ctx, "cannot check trust center file access", log.Error(err))
		// return false, gqlutils.Internal(ctx)
		return nil, nil
	}

	if fileAccess.Status != coredata.TrustCenterDocumentAccessStatusGranted {
		return nil, gqlutils.Forbiddenf(ctx, "access denied: no permission to access this file")
	}

	if ndaExists && !hasAcceptedNDA {
		return nil, gqlutils.Forbiddenf(ctx, "user has not accepted NDA")
	}

	fileData, err := trustService.TrustCenterFiles.ExportFile(ctx, input.TrustCenterFileID, identity.EmailAddress)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot export trust center file", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return &types.ExportTrustCenterFilePayload{
		Data: fmt.Sprintf("data:application/pdf;base64,%s", base64.StdEncoding.EncodeToString(fileData)),
	}, nil
}

// AcceptNonDisclosureAgreement is the resolver for the acceptNonDisclosureAgreement field.
func (r *mutationResolver) AcceptNonDisclosureAgreement(ctx context.Context, input types.AcceptNonDisclosureAgreementInput) (*types.AcceptNonDisclosureAgreementPayload, error) {
	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return nil, gqlutils.Unauthenticatedf(ctx, "unauthenticated")
	}
	trustCenter := compliancepage.CompliancePageFromContext(ctx)
	trustService := r.TrustService(ctx, trustCenter.ID.TenantID())

	httpReq := gqlutils.HTTPRequestFromContext(ctx)

	if _, err := r.iam.AuthService.UpdateIdentity(ctx, identity.ID, input.FullName); err != nil {
		var errNotFound *iam.ErrIdentityNotFound
		if errors.As(err, &errNotFound) {
			return nil, gqlutils.NotFound(ctx, err)
		}

		r.logger.ErrorCtx(ctx, "cannot update identity", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	if err := trustService.TrustCenterAccesses.AcceptNonDisclosureAgreement(
		ctx,
		&trust.AcceptNDARequest{
			TrustCenterID: trustCenter.ID,
			Email:         identity.EmailAddress,
			IPAddr:        httpReq.RemoteAddr,
		},
	); err != nil {
		r.logger.ErrorCtx(ctx, "cannot accept NDA", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return &types.AcceptNonDisclosureAgreementPayload{Success: true}, nil
}

// RequestDocumentAccess is the resolver for the requestDocumentAccess field.
func (r *mutationResolver) RequestDocumentAccess(ctx context.Context, input types.RequestDocumentAccessInput) (*types.RequestAccessesPayload, error) {
	trustCenter := compliancepage.CompliancePageFromContext(ctx)
	trustService := r.TrustService(ctx, trustCenter.ID.TenantID())

	document, err := trustService.Documents.Get(ctx, input.DocumentID)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot load document", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}
	if document.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		return nil, gqlutils.Invalidf(
			ctx,
			"document is publicly available and does not require access request",
		)
	}

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return nil, gqlutils.Unauthenticatedf(ctx, "authentication is required to request access")
	}

	access, err := trustService.TrustCenterAccesses.Request(
		ctx,
		&trust.TrustCenterAccessRequest{
			TrustCenterID:      trustCenter.ID,
			Email:              identity.EmailAddress,
			FullName:           identity.FullName,
			DocumentIDs:        []gid.GID{input.DocumentID},
			ReportIDs:          []gid.GID{},
			TrustCenterFileIDs: []gid.GID{},
		},
	)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot request document access", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return &types.RequestAccessesPayload{
		TrustCenterAccess: &types.TrustCenterAccess{
			ID:        access.ID,
			Email:     access.Email,
			Name:      access.Name,
			CreatedAt: access.CreatedAt,
			UpdatedAt: access.UpdatedAt,
		},
	}, nil
}

// RequestReportAccess is the resolver for the requestReportAccess field.
func (r *mutationResolver) RequestReportAccess(ctx context.Context, input types.RequestReportAccessInput) (*types.RequestAccessesPayload, error) {
	trustCenter := compliancepage.CompliancePageFromContext(ctx)
	trustService := r.TrustService(ctx, trustCenter.ID.TenantID())

	audit, err := trustService.Audits.GetByReportID(ctx, input.ReportID)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot load audit", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	if audit.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		return nil, gqlutils.Invalidf(
			ctx,
			"report is publicly available and does not require access request",
		)
	}

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return nil, gqlutils.Unauthenticatedf(ctx, "authentication is required to request access")
	}

	access, err := trustService.TrustCenterAccesses.Request(
		ctx,
		&trust.TrustCenterAccessRequest{
			TrustCenterID:      trustCenter.ID,
			Email:              identity.EmailAddress,
			FullName:           identity.FullName,
			DocumentIDs:        []gid.GID{},
			ReportIDs:          []gid.GID{input.ReportID},
			TrustCenterFileIDs: []gid.GID{},
		},
	)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot request report access", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return &types.RequestAccessesPayload{
		TrustCenterAccess: &types.TrustCenterAccess{
			ID:        access.ID,
			Email:     access.Email,
			Name:      access.Name,
			CreatedAt: access.CreatedAt,
			UpdatedAt: access.UpdatedAt,
		},
	}, nil
}

// RequestTrustCenterFileAccess is the resolver for the requestTrustCenterFileAccess field.
func (r *mutationResolver) RequestTrustCenterFileAccess(ctx context.Context, input types.RequestTrustCenterFileAccessInput) (*types.RequestAccessesPayload, error) {
	trustCenter := compliancepage.CompliancePageFromContext(ctx)
	trustService := r.TrustService(ctx, trustCenter.ID.TenantID())

	trustCenterFile, err := trustService.TrustCenterFiles.Get(ctx, input.TrustCenterFileID)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot load trust center file", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	if trustCenterFile.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		return nil, gqlutils.Invalidf(
			ctx,
			"trust center file is publicly available and does not require access request",
		)
	}

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return nil, gqlutils.Unauthenticatedf(ctx, "authentication is required to request access")
	}

	access, err := trustService.TrustCenterAccesses.Request(
		ctx,
		&trust.TrustCenterAccessRequest{
			TrustCenterID:      trustCenter.ID,
			Email:              identity.EmailAddress,
			FullName:           identity.FullName,
			DocumentIDs:        []gid.GID{},
			ReportIDs:          []gid.GID{},
			TrustCenterFileIDs: []gid.GID{input.TrustCenterFileID},
		},
	)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot request trust center file access", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return &types.RequestAccessesPayload{
		TrustCenterAccess: &types.TrustCenterAccess{
			ID:        access.ID,
			Email:     access.Email,
			Name:      access.Name,
			CreatedAt: access.CreatedAt,
			UpdatedAt: access.UpdatedAt,
		},
	}, nil
}

// LogoURL is the resolver for the logoUrl field.
func (r *organizationResolver) LogoURL(ctx context.Context, obj *types.Organization) (*string, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	return trustService.Organizations.GenerateLogoURL(ctx, obj.ID, 1*time.Hour)
}

// Viewer is the resolver for the viewer field.
func (r *queryResolver) Viewer(ctx context.Context) (*types.Identity, error) {
	identity := authn.IdentityFromContext(ctx)

	if identity == nil {
		return nil, nil
	}

	return &types.Identity{
		ID:            identity.ID,
		Email:         identity.EmailAddress,
		FullName:      identity.FullName,
		EmailVerified: identity.EmailAddressVerified,
		CreatedAt:     identity.CreatedAt,
		UpdatedAt:     identity.UpdatedAt,
	}, nil
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id gid.GID) (types.Node, error) {
	trustService := r.TrustService(ctx, id.TenantID())

	switch id.EntityType() {
	case coredata.OrganizationEntityType:
		organization, err := trustService.Organizations.Get(ctx, id)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot get organization", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}
		return types.NewOrganization(organization), nil

	case coredata.DocumentEntityType:
		document, err := trustService.Documents.Get(ctx, id)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot get document", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}
		return types.NewDocument(document), nil

	case coredata.FrameworkEntityType:
		framework, err := trustService.Frameworks.Get(ctx, id)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot get framework", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}
		return types.NewFramework(framework), nil

	case coredata.ReportEntityType:
		report, err := trustService.Reports.Get(ctx, id)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot get report", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}
		return types.NewReport(report), nil

	case coredata.AuditEntityType:
		audit, err := trustService.Audits.Get(ctx, id)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot get audit", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}
		return types.NewAudit(audit), nil

	case coredata.VendorEntityType:
		vendor, err := trustService.Vendors.Get(ctx, id)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot get vendor", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}
		return types.NewVendor(vendor), nil

	case coredata.TrustCenterEntityType:
		trustCenter, file, err := trustService.TrustCenters.Get(ctx, id)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot get trust center", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}
		return types.NewTrustCenter(trustCenter, file), nil

	case coredata.TrustCenterReferenceEntityType:
		reference, err := trustService.TrustCenterReferences.Get(ctx, id)
		if err != nil {
			r.logger.ErrorCtx(ctx, "cannot get trust center reference", log.Error(err))
			return nil, gqlutils.Internal(ctx)
		}
		return types.NewTrustCenterReference(reference), nil

	default:
		return nil, gqlutils.NotFoundf(ctx, "node %q not found", id)
	}
}

// CurrentTrustCenter is the resolver for the currentTrustCenter field.
func (r *queryResolver) CurrentTrustCenter(ctx context.Context) (*types.TrustCenter, error) {
	trustCenter := compliancepage.CompliancePageFromContext(ctx)

	trustService := r.TrustService(ctx, trustCenter.ID.TenantID())

	org, err := trustService.Organizations.Get(ctx, trustCenter.OrganizationID)
	if err != nil {
		panic(fmt.Errorf("cannot get organization: %w", err))
	}

	trustCenter, file, err := trustService.TrustCenters.Get(ctx, trustCenter.ID)
	if err != nil {
		panic(fmt.Errorf("cannot get trust center: %w", err))
	}

	response := types.NewTrustCenter(trustCenter, file)
	response.Organization = types.NewOrganization(org)

	return response, nil
}

// IsUserAuthorized is the resolver for the isUserAuthorized field.
func (r *reportResolver) IsUserAuthorized(ctx context.Context, obj *types.Report) (bool, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	trustCenter := compliancepage.CompliancePageFromContext(ctx)

	audit, err := trustService.Audits.GetByReportID(ctx, obj.ID)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot load document", log.Error(err))
		return false, gqlutils.Internal(ctx)
	}

	if audit.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		return true, nil
	}

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return false, nil
	}

	reportAccess, err := trustService.TrustCenterAccesses.LoadReportAccess(ctx,
		trustCenter.ID,
		identity.EmailAddress,
		obj.ID,
	)
	if err != nil {
		if errors.Is(err, trust.ErrMembershipNotFound) {
			return false, nil
		}
		if errors.Is(err, trust.ErrMembershipInactive) {
			return false, nil
		}
		if errors.Is(err, trust.ErrDocumentAccessNotFound) {
			return false, nil
		}

		r.logger.ErrorCtx(ctx, "cannot check report access", log.Error(err))
		return false, gqlutils.Internal(ctx)
	}

	return reportAccess.Status == coredata.TrustCenterDocumentAccessStatusGranted, nil
}

// HasUserRequestedAccess is the resolver for the hasUserRequestedAccess field.
func (r *reportResolver) HasUserRequestedAccess(ctx context.Context, obj *types.Report) (bool, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	trustCenter := compliancepage.CompliancePageFromContext(ctx)

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return false, nil // User is not authenticated, so no access requested
	}

	_, err := trustService.TrustCenterAccesses.LoadReportAccess(ctx,
		trustCenter.ID,
		identity.EmailAddress,
		obj.ID,
	)
	if err != nil {
		// FIXME check for not found and return without error in this case
		// r.logger.ErrorCtx(ctx, "cannot check report access", log.Error(err))
		// return false, gqlutils.Internal(ctx)
		return false, nil
	}

	return true, nil
}

// LogoFileURL is the resolver for the logoFileUrl field.
func (r *trustCenterResolver) LogoFileURL(ctx context.Context, obj *types.TrustCenter) (*string, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	return trustService.TrustCenters.GenerateLogoURL(ctx, obj.ID, 1*time.Hour)
}

// DarkLogoFileURL is the resolver for the darkLogoFileUrl field.
func (r *trustCenterResolver) DarkLogoFileURL(ctx context.Context, obj *types.TrustCenter) (*string, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	return trustService.TrustCenters.GenerateDarkLogoURL(ctx, obj.ID, 1*time.Hour)
}

// NdaFileURL is the resolver for the ndaFileUrl field.
func (r *trustCenterResolver) NdaFileURL(ctx context.Context, obj *types.TrustCenter) (*string, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	fileURL, err := trustService.TrustCenters.GenerateNDAFileURL(ctx, obj.ID, 15*time.Minute)
	if err != nil {
		// FIXME: add error not found check etc
		// r.logger.ErrorCtx(ctx, "cannot generate NDA file URL", log.Error(err))
		// return nil, gqlutils.Internal(ctx)
		return nil, nil
	}

	return &fileURL, nil
}

// Organization is the resolver for the organization field.
func (r *trustCenterResolver) Organization(ctx context.Context, obj *types.TrustCenter) (*types.Organization, error) {
	return obj.Organization, nil
}

// IsViewerMember is the resolver for the isViewerMember field.
func (r *trustCenterResolver) IsViewerMember(ctx context.Context, obj *types.TrustCenter) (bool, error) {
	membership := compliancepage.ComplianceMembershipFromContext(ctx)

	return membership != nil, nil
}

// HasAcceptedNonDisclosureAgreement is the resolver for the hasAcceptedNonDisclosureAgreement field.
func (r *trustCenterResolver) HasAcceptedNonDisclosureAgreement(ctx context.Context, obj *types.TrustCenter) (bool, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return false, nil // User is not authenticated, so no NDA accepted
	}

	hasAcceptedNDA, err := trustService.TrustCenterAccesses.HasAcceptedNonDisclosureAgreement(ctx, obj.ID, identity.EmailAddress)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot check if user has accepted NDA", log.Error(err))
		return false, gqlutils.Internal(ctx)
	}

	return hasAcceptedNDA, nil
}

// Documents is the resolver for the documents field.
func (r *trustCenterResolver) Documents(ctx context.Context, obj *types.TrustCenter, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.DocumentConnection, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	pageOrderBy := page.OrderBy[coredata.DocumentOrderField]{
		Field:     coredata.DocumentOrderFieldTitle,
		Direction: page.OrderDirectionAsc,
	}
	cursor := types.NewCursor(first, after, last, before, pageOrderBy)

	documentPage, err := trustService.Documents.ListForOrganizationId(ctx, obj.Organization.ID, cursor)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot list public documents", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return types.NewDocumentConnection(documentPage), nil
}

// Audits is the resolver for the audits field.
func (r *trustCenterResolver) Audits(ctx context.Context, obj *types.TrustCenter, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.AuditConnection, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	pageOrderBy := page.OrderBy[coredata.AuditOrderField]{
		Field:     coredata.AuditOrderFieldValidFrom,
		Direction: page.OrderDirectionDesc,
	}
	cursor := types.NewCursor(first, after, last, before, pageOrderBy)

	auditPage, err := trustService.Audits.ListForOrganizationId(ctx, obj.Organization.ID, cursor)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot list public audits", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return types.NewAuditConnection(auditPage), nil
}

// Vendors is the resolver for the vendors field.
func (r *trustCenterResolver) Vendors(ctx context.Context, obj *types.TrustCenter, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.VendorConnection, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	pageOrderBy := page.OrderBy[coredata.VendorOrderField]{
		Field:     coredata.VendorOrderFieldName,
		Direction: page.OrderDirectionAsc,
	}
	cursor := types.NewCursor(first, after, last, before, pageOrderBy)

	vendorPage, err := trustService.Vendors.ListForOrganizationId(ctx, obj.Organization.ID, cursor)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot list public vendors", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return types.NewVendorConnection(vendorPage, r, obj.ID), nil
}

// References is the resolver for the references field.
func (r *trustCenterResolver) References(ctx context.Context, obj *types.TrustCenter, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.TrustCenterReferenceConnection, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	pageOrderBy := page.OrderBy[coredata.TrustCenterReferenceOrderField]{
		Field:     coredata.TrustCenterReferenceOrderFieldRank,
		Direction: page.OrderDirectionAsc,
	}
	cursor := types.NewCursor(first, after, last, before, pageOrderBy)

	referencePage, err := trustService.TrustCenterReferences.ListForTrustCenterID(ctx, obj.ID, cursor)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot list public trust center references", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return types.NewTrustCenterReferenceConnection(referencePage), nil
}

// TrustCenterFiles is the resolver for the trustCenterFiles field.
func (r *trustCenterResolver) TrustCenterFiles(ctx context.Context, obj *types.TrustCenter, first *int, after *page.CursorKey, last *int, before *page.CursorKey) (*types.TrustCenterFileConnection, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	pageOrderBy := page.OrderBy[coredata.TrustCenterFileOrderField]{
		Field:     coredata.TrustCenterFileOrderFieldName,
		Direction: page.OrderDirectionAsc,
	}
	cursor := types.NewCursor(first, after, last, before, pageOrderBy)

	filter := coredata.NewTrustCenterFileFilter(
		coredata.WithTrustCenterFileVisibilities(
			coredata.TrustCenterVisibilityPublic,
			coredata.TrustCenterVisibilityPrivate,
		),
	)
	trustCenterFilePage, err := trustService.TrustCenterFiles.ListForOrganizationId(ctx, obj.Organization.ID, cursor, filter)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot list public trust center files", log.Error(err))
		return nil, gqlutils.Internal(ctx)
	}

	return types.NewTrustCenterFileConnection(trustCenterFilePage), nil
}

// IsUserAuthorized is the resolver for the isUserAuthorized field.
func (r *trustCenterFileResolver) IsUserAuthorized(ctx context.Context, obj *types.TrustCenterFile) (bool, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	trustCenter := compliancepage.CompliancePageFromContext(ctx)

	trustCenterFile, err := trustService.TrustCenterFiles.Get(ctx, obj.ID)
	if err != nil {
		r.logger.ErrorCtx(ctx, "cannot load trust center file", log.Error(err))
		return false, gqlutils.Internal(ctx)
	}

	if trustCenterFile.TrustCenterVisibility == coredata.TrustCenterVisibilityPublic {
		return true, nil
	}

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return false, nil
	}

	fileAccess, err := trustService.TrustCenterAccesses.LoadTrustCenterFileAccess(ctx,
		trustCenter.ID,
		identity.EmailAddress,
		obj.ID,
	)
	if err != nil {
		if errors.Is(err, trust.ErrMembershipNotFound) {
			return false, nil
		}
		if errors.Is(err, trust.ErrMembershipInactive) {
			return false, nil
		}
		if errors.Is(err, trust.ErrDocumentAccessNotFound) {
			return false, nil
		}

		r.logger.ErrorCtx(ctx, "cannot check trust center file access", log.Error(err))
		return false, gqlutils.Internal(ctx)
	}

	return fileAccess.Status == coredata.TrustCenterDocumentAccessStatusGranted, nil
}

// HasUserRequestedAccess is the resolver for the hasUserRequestedAccess field.
func (r *trustCenterFileResolver) HasUserRequestedAccess(ctx context.Context, obj *types.TrustCenterFile) (bool, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	trustCenter := compliancepage.CompliancePageFromContext(ctx)

	identity := authn.IdentityFromContext(ctx)
	if identity == nil {
		return false, nil // User is not authenticated, so no access requested
	}

	_, err := trustService.TrustCenterAccesses.LoadTrustCenterFileAccess(ctx,
		trustCenter.ID,
		identity.EmailAddress,
		obj.ID,
	)
	if err != nil {
		// FIXME check for not found and return without error in this case
		// r.logger.ErrorCtx(ctx, "cannot check trust center file access", log.Error(err))
		// return false, gqlutils.Internal(ctx)
		return false, nil
	}

	return true, nil
}

// LogoURL is the resolver for the logoUrl field.
func (r *trustCenterReferenceResolver) LogoURL(ctx context.Context, obj *types.TrustCenterReference) (string, error) {
	trustService := r.TrustService(ctx, obj.ID.TenantID())

	logoURL, err := trustService.TrustCenterReferences.GenerateLogoURL(ctx, obj.ID, 1*time.Hour)
	if err != nil {
		panic(fmt.Errorf("cannot generate logo URL: %w", err))
	}

	return logoURL, nil
}

// TotalCount is the resolver for the totalCount field.
func (r *vendorConnectionResolver) TotalCount(ctx context.Context, obj *types.VendorConnection) (int, error) {
	trustService := r.TrustService(ctx, obj.ParentID.TenantID())

	switch obj.Resolver.(type) {
	case *trustCenterResolver:
		count, err := trustService.Vendors.CountForTrustCenterId(ctx, obj.ParentID)
		if err != nil {
			panic(fmt.Errorf("cannot count vendors: %w", err))
		}
		return count, nil
	}

	panic(fmt.Errorf("not implemented: TotalCount for parent type %T", obj.Resolver))
}

// Audit returns schema.AuditResolver implementation.
func (r *Resolver) Audit() schema.AuditResolver { return &auditResolver{r} }

// Document returns schema.DocumentResolver implementation.
func (r *Resolver) Document() schema.DocumentResolver { return &documentResolver{r} }

// Framework returns schema.FrameworkResolver implementation.
func (r *Resolver) Framework() schema.FrameworkResolver { return &frameworkResolver{r} }

// Mutation returns schema.MutationResolver implementation.
func (r *Resolver) Mutation() schema.MutationResolver { return &mutationResolver{r} }

// Organization returns schema.OrganizationResolver implementation.
func (r *Resolver) Organization() schema.OrganizationResolver { return &organizationResolver{r} }

// Query returns schema.QueryResolver implementation.
func (r *Resolver) Query() schema.QueryResolver { return &queryResolver{r} }

// Report returns schema.ReportResolver implementation.
func (r *Resolver) Report() schema.ReportResolver { return &reportResolver{r} }

// TrustCenter returns schema.TrustCenterResolver implementation.
func (r *Resolver) TrustCenter() schema.TrustCenterResolver { return &trustCenterResolver{r} }

// TrustCenterFile returns schema.TrustCenterFileResolver implementation.
func (r *Resolver) TrustCenterFile() schema.TrustCenterFileResolver {
	return &trustCenterFileResolver{r}
}

// TrustCenterReference returns schema.TrustCenterReferenceResolver implementation.
func (r *Resolver) TrustCenterReference() schema.TrustCenterReferenceResolver {
	return &trustCenterReferenceResolver{r}
}

// VendorConnection returns schema.VendorConnectionResolver implementation.
func (r *Resolver) VendorConnection() schema.VendorConnectionResolver {
	return &vendorConnectionResolver{r}
}

type auditResolver struct{ *Resolver }
type documentResolver struct{ *Resolver }
type frameworkResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type organizationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type reportResolver struct{ *Resolver }
type trustCenterResolver struct{ *Resolver }
type trustCenterFileResolver struct{ *Resolver }
type trustCenterReferenceResolver struct{ *Resolver }
type vendorConnectionResolver struct{ *Resolver }
